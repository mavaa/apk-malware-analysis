import os
import re
import subprocess
import pandas as pd
import numpy as np
import xml.etree.ElementTree as ET

android_ns = "{http://schemas.android.com/apk/res/android}"
name_attr = "{0}name".format(android_ns)

def extract_app(app_path, out_path, apktool_path = None):
    if apktool_path == None:
        apktool_path = "apktool"

    if os.path.exists(out_path):
        os.remove(out_path)

    subprocess.run([apktool_path, "d", "-o", out_path, app_path])

def load_manifest(app_path):
    tree = ET.parse(app_path + "/AndroidManifest.xml")
    return tree.getroot()

def get_number_of_activities(manifest):
    number_of_activities = len(manifest.findall("./application/activity"))

    return number_of_activities

def get_permissions(manifest):
    app_permissions = []

    for permission in manifest.findall("./uses-permission"):
        app_permissions.append(permission.get(name_attr).split(".")[-1])

    return app_permissions

def search_ip_in_files(path):
    # return find_regex_in_path_recursive(path, r'[0-9]+(?:\.[0-9]+){3}') # Inaccurate
    return find_regex_in_path_recursive(path, r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b')

def search_domains_in_files(path):
    # return find_regex_in_path_recursive(path, r'http[s]?://\w+\.\w+') # Simple, but not perfect
    domains = find_regex_in_path_recursive(path, r'[w]{0,3}[\.]+[a-z0-9\-]+[\.]+[a-z0-9]{0,3}') # Better(?), but false positives -> fixed by filtering below
    
    # Fixed by filtering with "ending with a TLD" based on: https://data.iana.org/TLD/tlds-alpha-by-domain.txt
    filtered_domains = []

    # Top Level Domains
    with open('apktool/tlds.txt') as f:
        tlds = f.read().lower().split('\n')

    for domain in domains:
        split_domain = domain.lower().rsplit('.', 2) # Get two top levels
        tld = split_domain[-1] # Top level domain
        sld = split_domain[-2] # Second level domain
        if tld in tlds:
            filtered_domains.append(sld+'.'+tld)

    return filtered_domains


def count_files(path, toplevel = True):
    num_files = 0

    for file in os.listdir(path):
        filepath = path + os.sep + file
        if os.path.isfile(filepath):
            if file == "apktool.yml" and toplevel == True:
                # File generated by apktool, ignore
                continue

            num_files +=1

        else:
            if file == "original" and toplevel == True:
                # Folder with original apk content, ignore
                continue

            # Recurse through subfolders
            num_files += count_files(filepath, False)

    return num_files

def get_cert_country(path):
    country_dial = 0 # Return 0 if no country matched
    searchdir = path + os.sep + "original" + os.sep + "META-INF"
    for file in os.listdir(searchdir):
        if file.upper().endswith(".RSA"):
            filepath = searchdir + os.sep + file
            result = subprocess.run(["keytool", "-printcert", "-file", filepath], text = True, capture_output = True)

            firstline = result.stdout.partition("\n")[0]
            countrysplit = firstline.partition("C=")

            # Parse result and return only the country code
            df = pd.read_csv('apktool/country-codes.csv')
            country = countrysplit[2] # Set country based on C=
            
            if type(country) == str: # Only try to match strings
                columns = ['CLDR display name','ISO3166-1-Alpha-2','ISO3166-1-Alpha-3']
                country_match = np.where(df[columns].apply(lambda x: x.astype(str).str.lower()).eq(country.lower()).any(1))[0] # Search for country by name (all converted to lowercase)
                if country_match.size > 0: # If there was a match -> Array > 0
                    country_index = int(country_match[0])
                    country_dial = df.iloc[country_index]['Dial'] # Get dial code for country
            
    return country_dial

def find_regex_in_path_recursive(path, regex):
    matches = []

    for file in os.listdir(path):
        filepath = path + os.sep + file
        if os.path.isfile(filepath):
            # Do search in file

            # First run strings command to gen all strings in file
            result = subprocess.run(["strings", filepath], text = True, capture_output = True)

            # Then check for IP addresses
            for item in re.findall(regex, result.stdout):
                matches.append(item)
        else:
            # Serch recursively in folders
            matches = matches + find_regex_in_path_recursive(filepath, regex)

    # Remove duplicates
    matches = list(dict.fromkeys(matches))
    return matches

