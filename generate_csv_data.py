import apktool.extractor as extractor
import generator.generator as generator
import vtapi.vtapi as vtapi
import sqlite3
import hashlib
import os
import multiprocessing
import tqdm


# File paths
app_dir = 'app_data/malware_apps/'
extracted_dir = 'app_data/malware_apps_extracted/'
json_dir = 'app_data/malware_jsons/'
combined_filename = 'app_data/vt_combined.json'
csvs_dir = 'app_data/malware_csvs/'

def apktool_extract_task(app):
    app_path = app_dir + app # Where to find the apk
    out_path = extracted_dir + app # Where to put the extracted folder

    # Extract the apk file (Only needed to run once per app)
    if not os.path.exists(out_path):
        extractor.extract_app(app_path, out_path)

def csv_line_task(app_data):
    out_path = app_data["out_path"]
    app_path = app_data["app_path"]
    vt_data = app_data["vt_data"]
    sha256 = app_data["sha256"]
    csv_file_path = csvs_dir + sha256 + ".csv"

    if os.path.exists(csv_file_path):
        return # Dont run for existing apps

    # Load the app manifest and apktool file
    manifest = extractor.load_manifest(out_path)
    apktoolfile = extractor.load_apktoolfile(out_path)

    # Search for permissions
    app_permissions = extractor.get_permissions(manifest)

    # Get the nuber of activities defined
    number_of_activities = extractor.get_number_of_activities(manifest)

    # Search for ipv4 addresses
    ipv4s = extractor.search_ip_in_files(out_path)

    # Search for domains
    domains = extractor.search_domains_in_files(out_path)

    # Get number of files
    num_files = extractor.count_files(out_path)

    # Get cert country code
    country_dial = extractor.get_cert_country(out_path)

    # Get sdk version minimum and target
    sdk_version_minimum, sdk_version_target = extractor.get_sdk_versions(apktoolfile)

    # Get file size in bytes
    size_bytes = os.path.getsize(app_path)

    vt_app_labels = vtapi.get_labels(vt_data)

    # Write a line to a csv file
    generator.add_csv_line(csv_file_path,
            app_permissions,
            number_of_activities,
            len(ipv4s),
            len(domains),
            num_files,
            country_dial,
            sdk_version_minimum,
            sdk_version_target,
            size_bytes,
            sha256,
            vt_app_labels["top"],
            True)





# Generate a AVClass2 compatible file with json data
# from all apps to be analyzed.
# This line can be commented out after running the script once.
vtapi.combine_vt_files(json_dir, combined_filename)

# Run avclass2 on VT json data
av_labels = vtapi.run_avclass2(combined_filename)

apps = os.listdir(app_dir)
# apps = os.listdir('downloads/b')
# apps = os.listdir('decoded/t') # testing

# Extract apps using apktool
print("Running apktool...")
with multiprocessing.Pool() as pool_extract:
    pool_extract.map(apktool_extract_task, apps)
print("Done!")
print()

# This array will contain app data from apktool and VT, for use in the multiprocessing part of the code
app_data_array = []

count = 0
total = len(apps)

print("Preprocessing app data for labeling...")
for package_name in apps:
    # We need to get the vt data to pack with each app before going multi-process
    # This is via the sha256 hash through vtapi.get_app_by_sha256

    app = package_name
    app_path = app_dir + app # Where to find the apk
    out_path = extracted_dir + app # Where to put the extracted folder

    # Get file sha256 hash
    sha256_hash = hashlib.sha256()
    with open(app_path,"rb") as f:
        # Read and update hash string value in blocks of 4K
        for byte_block in iter(lambda: f.read(4096),b""):
            sha256_hash.update(byte_block)
    sha256_string = str(sha256_hash.hexdigest())

    # Get labels from VT
    vt_data = vtapi.get_app_by_sha256(sha256_string, json_dir, av_labels)

    app_data_array.append({
        "sha256": sha256_string,
        "app_path": app_path,
        "out_path": out_path,
        "vt_data": vt_data})

    count +=1
    print("Progress: [" + str(count) + "/" + str(total) + "]", end = "\r")

print("Done!")
print()

print("Making csvs....")

if not os.path.exists(csvs_dir):
    os.makedirs(csvs_dir)

with multiprocessing.Pool() as pool_label:
    for _ in tqdm.tqdm(pool_label.imap_unordered(csv_line_task, app_data_array), total=len(app_data_array)):
        pass

print("Done!")
